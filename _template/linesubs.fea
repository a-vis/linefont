@value = [{{#each values}}_{{ this.value }} {{/each}}];

# Option 1. Reversesub: + compact notation - 100+kb
# rsubs ignore final result of replacement and instead look at the initial sequence
# rsub _0 @value' by [to0 to1 to2 to3];
# rsub _1 @value' by [to-1 to0 to1 to2];
# rsub _2 @value' by [to-2 to-1 to0 to1];
{{#each values as |v1 i|}}
rsub _{{v1.value}} @value' by [{{#each ../values as |v2 i|}}to{{sub v2.value v1.value}} {{/each}}];
{{/each}}
# rsub _10 [_20 _30 _40]' by [to10 to20 to30];
# rsub _20 [_30 _40 _50]' by [to10 to20 to30];
# rsub _30 [_40 _50 _60]' by [to10 to20 to30];


# Option 2. Multiple subs, components in glyphs: - too lengthy notation - same big size - table overflow on building font
# sub _0 _0' by to0 _0;
# sub _0 _1' by to1 _1;
# sub _0 _2' by to2 _2;
# sub _1 _0' by to-1 _0;
# sub _1 _1' by to0 _1;
# sub _10 _20' by to10 _20;
# sub _20 _30' by to10 _30;

# Option 3. Option 1 + No components in subs, but additional subs. + compact notation + 70kb
{{#each values as |v|}}
sub to{{v.value}} by to{{v.value}} point;
{{/each}}
